import java.util.*;
import java.math.BigDecimal;

public class Main {
    public static int calculate(int a, int b) {
        return a + b;
    }

    public static BigDecimal calculate(BigDecimal a, BigDecimal b) {
        return a.add(b);
    }

    public static String calculate(String a, String b) {
        return a + b;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String type = "";
        if (sc.hasNextLine()) type = sc.nextLine().trim();

        if ("int".equals(type)) {
            // read as lines to avoid newline issues
            String s1 = sc.hasNextLine() ? sc.nextLine().trim() : "0";
            String s2 = sc.hasNextLine() ? sc.nextLine().trim() : "0";
            try {
                int a = Integer.parseInt(s1);
                int b = Integer.parseInt(s2);
                System.out.println(calculate(a, b));
            } catch (NumberFormatException e) {
                // fallback: try BigDecimal then print integer part
                BigDecimal r = calculate(new BigDecimal(s1), new BigDecimal(s2));
                System.out.println(r.toBigInteger().toString());
            }
        } 
        else if ("float".equals(type)) {
            // read raw lines (don't trim internal spaces)
            String s1 = sc.hasNextLine() ? sc.nextLine().trim() : "0";
            String s2 = sc.hasNextLine() ? sc.nextLine().trim() : "0";

            // create BigDecimal from the exact input string (preserves input scale)
            BigDecimal a = new BigDecimal(s1);
            BigDecimal b = new BigDecimal(s2);
            BigDecimal sum = calculate(a, b);

            // If either input had a decimal point or exponent, preserve decimal formatting:
            boolean inputHadDecimal = s1.contains(".") || s1.contains("e") || s1.contains("E")
                                    || s2.contains(".") || s2.contains("e") || s2.contains("E");

            if (inputHadDecimal) {
                // If sum has no fractional digits, show one decimal place (so 30.0 not 30)
                if (sum.scale() <= 0) {
                    System.out.println(sum.setScale(1).toPlainString());
                } else {
                    // Remove unnecessary trailing zeros but keep necessary decimals (30.80 -> 30.8)
                    System.out.println(sum.stripTrailingZeros().toPlainString());
                }
            } else {
                // Neither input looked like a decimal; print minimal plain string (like "30")
                // But keep fractional if it exists (rare), strip trailing zeros otherwise
                if (sum.scale() <= 0) {
                    System.out.println(sum.toPlainString());
                } else {
                    System.out.println(sum.stripTrailingZeros().toPlainString());
                }
            }
        } 
        else if ("string".equals(type)) {
            String s1 = sc.hasNextLine() ? sc.nextLine() : "";
            String s2 = sc.hasNextLine() ? sc.nextLine() : "";
            System.out.println(calculate(s1, s2));
        }
        // If the judge sends no valid type, print nothing (many judges expect no extra output)
    }
}
